# 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

## 핵심 내용

Java 8 이전에는 인터페이스에 메서드를 추가하면 기존에 이를 구현한 모든 클래스에서 컴파일 오류가 발생했다.
Java 8에서는 디폴트 메서드가 도입되면서 인터페이스에 메서드를 추가할 수 있게 되었지만,
여전히 이 기능에는 위험이 따른다.

## 디폴트 메서드의 위험성

Java 8에서는 인터페이스에 디폴트 메서드(`default method`)를 추가할 수 있게 되었다.
디폴트 메서드는 인터페이스에서 메서드 선언뿐만 아니라 기본 구현까지 제공한다.

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```

이러한 디폴트 메서드는 기존 구현체에 런타임 오류 없이 새로운 메서드를 추가할 수 있게 해주지만,
모든 상황에서 안전하지는 않다.

### 문제점 사례: `Collection` 인터페이스의 `removeIf`

Java 8에서 `Collection` 인터페이스에 추가된 `removeIf` 메서드는 주어진 조건에 맞는 원소를 제거하는 기능을 수행한다.
그러나 이 메서드가 모든 `Collection` 구현체와 매끄럽게 연동되는 것은 아니다.

예를 들어, Apache Commons 라이브러리의 `SynchronizedCollection`은 모든 메서드 호출을 동기화하는 래퍼 클래스다.
Java 8 이전에 만들어진 이 클래스는 `removeIf` 메서드를 재정의하지 않았고,
따라서 디폴트 구현을 물려받았다. 그 결과, 이 메서드를 호출하면 동기화가 무력화되어 안전하지 않은 동작이 발생할 수 있다.

## 디폴트 메서드 추가의 현실적 접근

1. **새로운 인터페이스**
    - 새로운 인터페이스를 설계할 때는 표준적인 메서드 구현을 제공하는 데 디폴트 메서드가 유용하다.
    - 그러나 디폴트 메서드라도 인터페이스에 추가하기 전에 테스트해야 한다.
2. **기존 인터페이스**
    - 기존 인터페이스에 디폴트 메서드를 추가하는 것은 항상 위험한 일이다.
    - 새로운 메서드가 기존 구현체와 충돌할 가능성이 있으며, 이를 100% 예방할 수 없다.

## 결론

인터페이스 설계는 세심한 주의가 필요하다. 인터페이스를 릴리스한 후에 결함을 발견하더라도 수정하기 어려울 수 있다.
디폴트 메서드라는 도구가 생겼더라도, 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.

새로운 인터페이스라면 릴리스 전에 테스트를 거쳐야 하며, 기존 인터페이스에 디폴트 메서드를 추가하는 것은

기존 구현체들의 동작을 면밀히 검토한 후에 진행해야 한다.